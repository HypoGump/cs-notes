{"./":{"url":"./","title":"关于本书","keywords":"","body":"cs-notes 用于记录计算机学习笔记，有问题欢迎 邮件 联系我，或通过 issues 提出 By HypoGump，使用知识共享 署名-相同方式共享 4.0协议发布            此页面修订于： 2020-10-06 11:38:28 "},"Book/effective-c++.html":{"url":"Book/effective-c++.html","title":"Effective C++","summary":"Effective C++ 读书笔记","keywords":"","body":"Effective C++ 第一章 条款02 尽量以 const / enum / inline 替换 #define 使用define时，你所使用的名称可能并未进入记号表 define只是单纯的做文本替换，可能会导致代码膨胀。比如 #define X 1.11 会使目标码出现多份 1.11，使用 const double x = 1.11 就不会有这个问题 const 成员变量需要在类外再次声明，一般放在实现文件中 define 没有作用域的限制，只要被定义，除非 undef，否则一直有效 对于形似函数的宏应该考虑用 inline 函数替换 第二章 构造、析构和赋值操作符 条款05 了解 C++ 默默编写并调用了哪些函数 一个空类，编译器会自动声明 构造函数、拷贝构造函数、拷贝赋值操作符、析构函数 。都是public且inline的 。当它们 被调用时才会被实际创建 。 class Empty {}; // 编译后 class Empty { public: Empty() {} Empty(const Empty& rhs) {} ~Empty() {} Empty& operator= (const Empty& rhs) {} } 当你自己声明了一个构造函数，编译器就不会自动生成无参的默认构造函数。 默认的拷贝构造函数，对于有自己的拷贝构造函数的成员，调用其拷贝构造函数；对于内置类型，则拷贝他的“每一个bit” 对于内含 引用成员/const 成员 的类，需要自己定义拷贝赋值操作符 对于基类的 拷贝赋值操作符 声明为private的派生类，编译器不会给派生类生成 拷贝赋值操作符 条款06 不想编译器生成函数就要明确拒绝 将函数声明为 private，并且只声明不定义 C++ 11 中应该使用 delete 关键字 条款07 为多态基类声明 virtual 析构函数 delete 一个指向派生类的基类指针，且基类析构函数非虚函数，是未定义行为 如果一个类包含虚函数，那么它的析构函数也应该是虚函数 如果class不打算作为基类使用，那就不要使用 virtual 关键字 条款08 别让异常逃离析构函数 析构函数中的异常应该被”吞下“（忽略）或者终止程序 客户如果需要对某个操作的异常做出反应，类应该提供一个该操作的普通函数 条款09 不在构造和析构过程中调用virtual函数 在构造函数中调用虚函数的话，因为基类先于派生类构建，基类构造函数调用虚函数时要么链接错误（无定义时），要么调用的是基类的函数（有定义时） 在析构函数中调用虚函数的话，因为派生类先于基类析构，基类析构函数调用虚函数时派生类已经失效了 条款10 令 operator= 返回一个 reference to *this 条款11 在 operator= 中处理\"自我赋值\" 条款12 复制对象时勿忘其每个成分 By HypoGump，使用知识共享 署名-相同方式共享 4.0协议发布            此页面修订于： 2020-10-06 11:38:28 "},"Book/effective-modern-c++.html":{"url":"Book/effective-modern-c++.html","title":"Effective Modern C++","summary":"Effective Modern C++ 读书笔记","keywords":"","body":"Effective Modern C++ 第一章 类型推导 条款1 理解类型推导 template void f(ParamType param) # 调用 f(expr) T 和 ParamType 很多时候推导出来是不一样的，因为 ParamType 常常带有修饰，比如 const 、& 等。 template void f(const T& param) # 调用 int x = 0; f(x); T 推导为 int ， ParamType 推导为 const int& 。 因此 T 的类型推导不仅依赖于 expr 的类型，还依赖于 ParamType 的形式。 case 1：ParamType是引用或指针，但不是通用引用(Universal Reference) 如果 expr 是引用，忽略引用部分 按照模式匹配的规则根据 ParamType 推导 T case 2：ParamType是通用引用 如果 expr 是左值，T 和 ParamType 推导为左值引用 这是 T 被推导为引用的唯一一种情况 虽然 ParamType 声明语法跟右值引用相同，但其被推导为左值引用 如果 expr 是右值，根据 case 1 规则推导 case 3：ParamType既不是引用也不是指针 如果 expr 是引用，忽略引用部分 忽略引用之后，如果 expr 由 const / volatile 修饰，将其忽略 template void f(T param) # 调用 const char* const ptr = // ptr is const pointer to const object \"Fun with pointers\"; f(ptr); // type deduced const char* 数组参数 数组按值传递时，T 推导为 const type* （指针） 数组按引用传递时，T 推导为 const type (&)[N] （数组），N 为数组大小 # 可在编译期获得数组大小 template constexpr std::size_t arraySize(T (&)[N]) noexcept { return N; } 函数参数 函数按值传递时，T 推导为函数指针 函数按引用传递时，T 推导为函数引用 条款2 理解auto类型推导 将 auto 看作 条款1 中的 T，type specifier 看作 ParamType，规则同样适用 auto 类型推导 与 模板类型推导 的区别在于：auto 将 braced initializer 推导为 std::initializer_list ，模板类型推导则会拒绝这种类型 auto x = {11, 23, 9}; // x's type is std::initializer_list template void f(T param); f({11, 23, 9}); // can't deduce type for T template void f(std::initializer_list param); f({11, 23, 9}); // T's type is int C++ 14 中 auto 作为函数返回值类型时，按照模板类型推导规则进行 条款3 理解 decltype decltype 准确地返回传递给它的对象类型 // 此时 auto 不做类型推导，而表示尾置返回类型 template auto authAndAccess(Container& c, Index i) -> decltype(c[i]) // refinement { authenticateUser(); return c[i]; } decltype(auto) 表示根据 decltype 规则进行类型推导 For lvalue expressions of type T other than names, decltype always reports a type of T&. C++14 supports decltype(auto), which, like auto, deduces a type from its initializer, but it performs the type deduction using the decltype rules. 条款4 如何查看推导类型 IDE 自带类型推导功能 编译器诊断 运行时输出，标准库(不一定正确) / boost库(√) 第二章 auto 条款5 尽量使用auto，而不是显式声明 条款6 Use the explicitly typed initializer idiom when auto deduces undesired types 第三章 Modern C++ 条款7 构建对象时区分()和{} 花括号初始化时使用范围最广的初始化语法，它能避免 narrowing conversions，不会产生 most vexing parse double x, y, z; int sum{x + y + z}; // error! narrowing conversion int sum(x + y + z); // OK, double is truncated to int Widget w1(); // function declaration Widget w2{}; // no args initialization 构造函数重载解析时，花括号初始化会优先匹配参数为 std::initializer_list 的构造函数（只要类型可以隐式转换，都优先匹配）。 典型例子 vector v(10, 20); // 10 elements, value 20 vector v{10, 20}; // 2 elements, value 10 and 20 条款8 尽量用 nullptr，而不是 0 和 NULL 0 和 NULL 都不是指针类型，因此作为参数传递时不会调用以指针为参数的重载 nullptr 实际类型为 std::nullptr_t ，既不是数值类型也不是指针类型，但是你可以将其视作任意类型的指针 条款9 尽量用 alias declaration，而不是 typedef typedef 不支持模板化，alias declaration 支持 template // MyAllocList using MyAllocList = std::list>; // is synonym for std::list> MyAllocList lw; // client cod // typedef 需要用结构体包裹 template // MyAllocList::type struct MyAllocList { // is synonym for typedef std::list> type; // std::list> }; MyAllocList::type lw; // client code 条款10 尽量用 scoped enums，而不是 unscoped enums /* unscoped enums */ enum Color {black, white, red}; auto white = false; // error /* scoped enums */ enum class Color {black, white, red}; auto white = false; // fine Color c = white; // error Color c = Color::white; // fine scoped enums 可以减少命名空间污染 unscoped enums 有类型隐式转换的优势，默认是整型，并可以隐式转换为其他数值类型；scoped enums 则不允许隐式转换，可以显式转换 scoped enums 允许前向声明，unscoped enums 只有制定了数据类型才能前向声明 都支持指定使用的数据类型，scoped enums 默认使用 int，unscoped enums 没有默认类型 条款11 使用 delete 函数，而不是 private 未定义函数 delete 函数一般声明为 public，因为权限检查先于 delete 状态检查。如果声明为 private ，编译期报错是关于 private 的，使得报错信息模糊。 delete 可以修饰 任何 函数 // 防止隐式转换 bool isLucky(int num); bool isLucky(char) = delete; bool isLucky(bool) = delete; // 也会拒绝 float 参数，C++倾向于将float转换为double bool isLucky(double) = delete; delete 还可用于禁用部分模板实例化 template void processPointer(T* ptr); template<> void processPointer(void*) = delete; template<> void processPointer(char*) = delete; 对于类内模板，模板实例化必须写在命名空间域内，而不是类域内。所以无法通过声明private 并 不定义 来禁用类内模板实例。应该使用 delete。 条款12 将 overriding function 声明为 override 在派生类中覆写的虚函数声明为 override，便于编译器查错 reference qualifiers 可以区别对待左值对象和右值对象 class Widget { public: using DataType = std::vector; … DataType& data() & // for lvalue Widgets, return lvalue { return values; } DataType data() && // for rvalue Widgets, return rvalue { return std::move(values); } … private: DataType values; }; Widget makeWidget(); // factory function // calls lvalue overload for Widget::data, copy constructs vals1 auto vals1 = w.data(); // calls rvalue overload for Widget::data, move constructs vals2 auto vals2 = makeWidget().data(); 条款13 尽量用 const_iterator，而不是 iterator 尽量用 const_iterator，而不是 iterator // C++ 11 未提供 cbegin cend rbegin rend crbegin crend 等 free function template auto cbegin(const C& container) -> decltype(std::begin(container)) { return std::begin(container); } 为了代码的泛用性，最好使用非成员函数的 begin / end / cbegin / cend 等 条款14 如果函数不会抛出异常，声明为 nonexcept 条款15 尽可能使用 constexpr constexpr 对象都是 const 的，且被编译期值初始化 当函数被声明为 constexpr 时，若传入的参数是编译期可以获知的，那它可以产生编译期值；若传入参数是运行时获知，那它跟普通函数行为一致 在 C++ 11 中，constexpr 函数只能含有一条 return 语句（可以用 “？：” 代替 if else，用递归代替循环）；C++ 14 中没有此限制 constexpr 函数只能接受和返回常量类型（literal types）。C++ 11 中，除了 void 之外的所有 built-in 类型都符合条件。用户自定义类型也可以是常量类型，因为构造函数和其他成员函数可以是 constexpr。 C++ 11 中，constexpr 成员函数隐式定义为 const（不能修改成员值），且不支持 void 作为返回类型，所以 setter 函数不能被声明为 constexpr。C++ 14 中无此限制。 条款16 确保 const 成员函数线程安全 确保 const 成员函数线程安全，除非你能确保它们永远不会被并发调用 std::atomic 变量可能可以提供比 mutex 更好的性能，但是它只适用于只对一个变量或内存位置进行操作的情况 条款17 理解特殊成员函数的生成 第四章 智能指针 条款18 使用 std::unique_ptr 进行独有资源管理 std::unique_ptr 应用的典型场景就是工厂函数返回对象 std::unique_ptr 是 move-only 的 析构时默认调用 delete，也可以自定义(custom deleters)。推荐使用无捕获的 lambda 表达式，因为它不会增加智能指针的体积；用函数指针至少会导致 std::unique_ptr 增加函数指针的大小。 std::unique_ptr 很容易转换为 std::shared_ptr 条款19 使用 std::shared_ptr 进行共享资源管理 std::shared_ptr 是原始指针的两倍大小。包含一个指向资源的 raw pointer 和 一个指向引用计数的 raw pointer 引用计数的内存必须动态分配 引用计数的增减必须是原子的。你应当认为原子操作的代价是相当昂贵的 移动构造 比 拷贝构造 更加高效，前者不改变引用计数 std::unique_ptr 的自定义析构函数是 自身的一部分 会改变其类型/大小，std::shared_ptr 则不会，而是将其存放在 共享的控制块(control block) 中。 std::unique_ptr upw(new Widget, loggingDel); std::shared_ptr spw(new Widget, loggingDel); 控制块的构建 std::make_shared 总是创建一个控制块 当 std::shared_ptr 由独有权限指针(比如 std::unique_ptr)构建时，创建控制块 由 raw pointer 构造 std::shared_ptr 时，创建控制块 std::enable_shared_from_this ，使用 CRTP (Curiously Recurring Template Pattern) 设计模式。 避免由 raw pointer 创建 std::shared_ptr 条款20 用 std::weak_ptr 来避免空悬指针 expired() 用于检测所指对象是否还存在 lock() 是为了提供 检测+获取 的原子操作。如果检测和获取分开，可能会导致 race condition 用 std::weak_ptr 来避免空悬指针 使用场景：缓存、observer lists、防止 std::shared_ptr 循环引用 std::weak_ptr 与 std::shared_ptr 大小一致，操作 控制块 中的 二级引用(second reference) 条款21 std::make_unique / std::make_shared 代替直接适用 new std::make_shared - C++ 11，std::make_unique - C++ 14 使用 make function 可以避免代码重复，减少编译时间 make function 是异常安全的 std::make_shared 可以产生更高效的代码 // 需要两次内存分配，一次给 Widget，一次给控制块 std::shared_ptr spw(new Widget); // 一次内存分配，Widget和控制块一起保存 auto spw = std::make_shared(); make function 的限制，std::unique 只有前两条限制，std::shared_ptr 限制条件更多 make function 不允许自定义析构函数 make function 不支持花括号初始化，需要借助 auto 推导实现 // create std::initializer_list auto initList = { 10, 20 }; // create std::vector using std::initializer_list ctor auto spv = std::make_shared>(initList); 由于 make function 分配一块内存共同持有对象和控制块，因此，只有当所有 shared_ptr 和 weak_ptr 都失效时，内存才会被释放；仅所有 shared_ptr 失效时，对象不会被释放。所以当内存吃紧时，酌情使用 当需要自定义内存管理（分配/析构）时，无法使用 make_shared 条款22 When using the Pimpl Idiom, define special member functions in the implementation file. Pimpl - pointer to implementation Pimpl Idiom 是一种减少编译期依赖的方法，可以减少编译时间 对于 std::unique_ptr ，建议将特殊函数声明/实现分离，即使默认生成函数就满足要求，也建议将其显式声明，在 .cc/.cpp 中实现。 上述建议不适用与 std::shared_ptr，因为编译器生成特殊函数时，不要求 shared_ptr(自定义内存分配函数不是对象的一部分) 指向的对象是 complete 第五章 右值引用、移动语义、完美转发 条款23 std::move 和 std::forward std::move 和 std::forward 在运行时不产生可执行代码，它们仅做类型转换 std::move 无条件进行右值转换 std::forward 执行有条件的类型转换，当且仅当输入参数被右值初始化(绑定)时，将其转换为右值。典型场景：函数模板接受通用引用(Universal reference)参数并传递给另一个函数。 函数的参数作为参数传递给其内部的函数时，是一个左值，若想维持其类型不变，就用 std::forward 如果你想移动对象，不要用 const 修饰它。 条款24 区分 universal references 和 rvalue references template void f(T&& param); // universal reference auto&& var1 = var2; // universal reference universal reference (forwarding reference) 必须严格遵守 type&& 形式，但是如果没有发生类型推导，type&& 就表示右值引用 universal reference 既可绑定左值，也可绑定右值 条款25 Use std::move on rvalue references, std::forward on universal references 在最后一次使用变量时使用 std::move / std::forward 对于 return by value 的函数，将右值引用和universal reference做相同处理。（std::forward）???? 除非局部对象不适合 RVO (return value optimization) ，否则不要对其使用 std::move / std::forward 条款26 Avoid overloading on universal references 条款28 理解引用折叠 (reference collapsing) 条款29 Assume that move operations are not present, not cheap, and not used 条款30 熟悉完美转发的失效情形 第六章 Lambda lambda表达式基本语法 [captured param](param list) mutable throw() -> type { expressions... } 条款31 避免默认捕捉模式 默认引用捕捉模式时，若 lambda 生命周期长于局部变量，会造成空悬引用 默认按值捕捉模式时，可能会导致空悬指针 / 对于static storage duration 变量，会让人误解其为self-contained class Widget { public: void addFilter() const; private: int divisor; } void Widget::addFilter() const { // 实际上复制了this指针，导致this指针泄露 filter.emplace_back( [=](int value){return value % divisor == 0;}); } void Widget::addFilter() const { // error 不存在局部变量 divisor filter.emplace_back( [divisor](int value){return value % divisor == 0;}); } void Widget::addFilter() const { // error divisor 不可得 filter.emplace_back( [](int value){return value % divisor == 0;}); } void Widget::addFilter() const { // 看似按值捕捉，实际是直接使用的divisor，所有lambda内的值都会随着divisor变化而变化 static int divisor = 1; filter.emplace_back( [=](int value){return value % divisor == 0;}); ++divisor; } 条款32 Use init capture to move objects into closures C++ 14 使用 init capture 更好 auto func = [pw = std::make_unique()](){ return pw->isValidated() && pw->isArchived(); } C++ 11 可以用 std::bind 模拟 init capture auto func = std::bind( [](const std::unique_ptr& pw) { return pw->isValidated() && pw->isArchived(); }, std::make_unique()); 条款33 Use decltype on auto&& parameters to std::forward them C++ 14 支持 generic lambda // 有限参数 auto f = [](auto&& param) { return func(normalize(std::forward(param)); } // 可变参数 auto f = [](auto&&... param) { return func(normalize(std::forward(param)...); } 条款34 尽量使用 lambda，而不是 std::bind lambda 更加易读，表达能力更强（比如能区分重载函数），更可能比 std::bind 高效 在 C++ 11 中，std::bind 对于模拟 move capture 以及 绑定模板函数调用操作符 时有用 第七章 并发API 条款35 Prefer task-based programming to thread-based std::thread 不提供直接获取异步运行函数返回值的手段，且抛出异常时，程序终止。 并发C++程序中“线程”的三种含义 硬件线程：实际执行计算的线程。当前的计算机架构每核支持一个或多个线程。 软件线程（OS线程/系统线程）：由操作系统管理/调度在硬件线程上执行的线程。软件线程可以多于硬件线程。有限资源 ，试图创建超过系统承载能力的软件线程会抛出 std::system_error 异常，即使声明 noexcept 也会抛出。 std::thread：C++进程中的对象，作为操作底层软件线程的 handle。std::thread 可以是 “null” handle，即不控制任何软件线程。 oversubscription 问题：ready-to-run 的软件线程数多于硬件线程数 导致频繁的线程切换，CPU cache 被新线程污染，保存不了多少有用的指令/数据 std::async 不保证会创建一个新线程 以下情况直接使用线程合适 当你需要使用底层线程API时，std::thread 提供了 native_handle 当你需要且有能力优化线程使用时 当C++并发API 不支持你实现线程技术时 条款36 当异步很关键时，指明 std::launch::async 两种启动策略(launch policy) std::launch::async：函数 f 必须异步执行，即另起线程 std::launch::deferred：当调用 get / wait 方法时才会异步执行 f，调用方会一直阻塞直到 f 完成；如果一直不调用 get / wait，f 就永远不会执行 // run f using default launch policy // 默认策略允许 f 同步/异步 运行 auto fut1 = std::async(f); // run f either async or deferred auto fut2 = std::async(std::launch::async | std::launch::deferred,f); 假设线程 t 执行 std::async(f) 不能确定 f 是否与 t 并发执行，可能被 deferred 不能确定 f 是否运行在与调用 get/wait 的线程不同的线程 不能确定 f 是否运行 使用默认策略 std::async 的条件 task 不需要与调用 get/wait 的线程并发执行 不会影响 thread_local 变量的读写 保证 get/wait 一定会被调用，或者 task 是否执行也无关紧要 调用 wait_for 或 wait_until 的代码必须考虑检查 deferred 状态 不满足以上条件时，指定 std::launch::async 条款37 在任意执行路径上保证 std::thread 都是 unjoinable 的 unjoinable 的 std::thread 包括 默认构造的 std::thread 移动构造时失去控制权的 std::thread 已调用 join 的 std::thread 已调用 detach 的 std::thread 析构 joinable 的线程会导致程序终止 在数据成员的末尾声明 std::thread 对象 在析构时 join / detach 都可能导致异常现象，更为合适的方法是使用可中断线程，参考C++ Concurrency in Action 9.2 节 条款38 认识不同的 thread handle destructor 行为 std::future / std::promise 的结果保存于 Shared State （堆对象）中 future 析构函数的行为 The destructor for the last future referring to a shared state for a nondeferred task launched via std::async blocks until the task completes The destructor for all other futures simply destroys the future object future 析构函数正常情况下仅销毁 future 的数据成员 最后一个指向 shared state 的 non-deferred task(由std::async启动) 的 future 会阻塞，直至 task 完成 条款39 考虑使用 void futures 进行一次性事件通信 用条件变量做事件唤醒的弊端 如果唤醒线程 notify 先于等待线程 wait 执行，可能会发生信号丢失 wait 可能会被 恶意唤醒 (spurious wakeups) 共享bool变量的弊端 等待线程轮询 bool 值会造成浪费 联合使用条件变量和共享变量，不会存在问题，但是相当于双重检查，不够clean one-shot 事件推荐使用 void promise/future/shared_future，会带来堆内存分配的开销 std::promise p; p.get_future().wait(); p.set_value(); 条款40 使用 std::atomic 做并发，volatile 修饰 special memory std::atomic 用于多线程编程时声明原子数据及其操作，删除了拷贝构造、移动构造、移动赋值。默认为 sequential consistency volatile 用于提示编译不要优化读写操作，用于处理 special memory int x; auto y = x; y = x; // may be optimized as // auto y = x; volatile int x; auto y = x; // read x y = x; // read x again (can't be optimized) // can't be optimized 第八章 微调 条款41 对于 易于move和总是拷贝的可拷贝参数，按传值的方式传参 条款42 用 emplacement 代替 insertion std::vector vs; vs.push_back(\"xyzzy\"); // wrong vs.push_back(std::string(\"xyzzy\")); // right, 但是引入了两次构造和一次析构 vs.emplace_back(\"xyzzy\"); // 直接构造容器内元素，只要一次构造 emplacement 和 insertion 哪个实际更快，需要实际 benchmark 测试。但是仍然有几个条件作为启发式，当满足时，emplacement 通常更快 构造插入而非赋值插入时。Node-based 的容器通常都是构造插入 。 传入的参数类型与容器保存的类型不一致时 容器允许重复元素 当容器保存智能指针时，使用 insertion 可以防止内存泄漏。因为避免了构造时异常。 emplacement 使用直接初始化，你需要自己保证传入的参数是有效的。 regexes.emplace_back(nullptr); // compiles. but behavior undefined regexes.push_back(nullptr); // error std::regex r1 = nullptr; // error std::regex r2(nullptr); // compiles By HypoGump，使用知识共享 署名-相同方式共享 4.0协议发布            此页面修订于： 2020-10-06 11:38:28 "},"Interview/c++面试.html":{"url":"Interview/c++面试.html","title":"C++面试","keywords":"","body":"C++面试题 数据结构 字典树构造及其优化应用 struct Trie { bool isEnd; Trie* next[26]; Trie() : isEnd(false) { memset(next, NULL, sizeof(next)); } void insert(string w) { Trie* cur = this; for (auto& c : w) { if (cur->next[c - 'a'] == nullptr) { cur->next[c - 'a'] = new Trie(); } cur = cur->next[c - 'a']; } cur->isEnd = true; } bool search(string w) { Trie* cur = this; for (auto& c : w) { if (cur->next[c - 'a']) { cur = cur->next[c - 'a']; } else return false; } return cur->isEnd; } }; 红黑树的特性，及其在 STL 中的应用 特性 根是黑的，叶子是黑的 红色节点不能相邻 从根到叶子节点路径上的黑色节点数量相等 复杂度：恢复红黑树的性质需要 $O(logN)$ 次的颜色变更 和 不超过三次的旋转操作 STL 中应用：set、map 贪心与动态规划 动态规划：将一个问题拆解成几个子问题，然后推断出大问题的解 问题的解可由其子问题得到 无后效性：给定某一阶段的状态，该阶段之后的过程不受该阶段之前各阶段状态的影响 最优子结构：大问题的最优解可由小问题的最优解得出 贪心：每次选择当前情况最优的选择 01背包问题的详细解释 算法题 环形公路上加油站算法（Leetcode 134） 搜索旋转数组（Leetcode 33、81） n对括号正常匹配情况的枚举输出 无序数组查找 top K 元素 K 个排序数组找中位数（Leetcode 4） 并查集（Leetcode 1202） 链表反转 数组全排列 数组所有非递减子序列的枚举 数据流中的中位数（Leetcode 295） 子集（Leetcode ） 寻找重复数 / 环形链表（Leetcode 287 / 142） C/C++ 面向对象特性 封装：把客观事物封装为抽象类 继承：目的是复用已有类的功能 多态：通过虚函数实现 内存模型（按从高地址到低地址的顺序从上至下排列） 内核内存：对用户代码不可见 用户栈：存放函数调用上下文和临时/自动变量 共享库的内存映射区 运行时堆：动态内存分配 未初始化数据段：存放未被初始化/初始化为0的全局/静态变量 初始化数据段：存放初始化的全局变量和静态变量，可细分为初始化只读区和初始化读写区 代码段：存放可执行指令，只读，通常是共享的 堆和栈的区别 栈：系统自动分配释放，存放局部变量和函数调用上下文等。是一块连续的内存区域，有一个预先设定的值，申请空间大于栈空间就会造成栈溢出。 堆：由程序主动申请和释放。堆分配的空间是由操作系统管理的不连续的空闲空间，大小受限于计算机有效的虚拟内存 include 顺序 #include \"xx.h\" （从上往下依次查找，直到找到） 当前文件夹 在之前include打开的文件所在文件夹查找 编译器设置的路径内查找 INCLUDE 环境变量内搜索 #include 在编译器设置的路径内查找 INCLUDE 环境变量内搜索 extern 修饰变量时，表示声明的变量可以在本模块和其他模块中使用 extern \"C\" 仅表示链接约定 .c 按照 C 语言编译，.cc/.cpp 文件按照 C++ 编译。当 C++ include 的头文件由C语言实现时，需要将其用 extern \"C\" 包括，表示按 C 的链接方式查找函数。 static 和 const static 修饰局部变量，将其生命周期变为静态 修饰全局变量，限制其作用域为本模块 修饰成员变量/成员函数，表示成员变量/成员函数是类内共享的，不需要创建对象即可访问 const 修饰变量，表示值是常量 修饰指针，分为指向常量的指针 和 指针常量。指向常量的指针意思是不能通过该指针改变所指的对象；常量指针表示指针存的内存地址是不可变的，但是该地址上的内容是可变的 修饰成员函数，表示该函数不会修改成员变量，需要修改的话成员变量需要用 mutable 修饰 volatile 保证对特殊地址的稳定访问，每次读取都是从所在地址重新读取，即使它前面的指令刚对该地址读取过数据，防止编译器优化 new / delete 和 malloc / free delete this 引用计数销毁对象可能会用到，当引用计数为 0 时 “自杀” 类型转换 static_cast ：在编写程序时能够明确类型转换时使用，不会改变底层 const、volatile 等属性。不提供运行时检查。 const_cast ：用于移除 const、volatile 等属性 dynamic_cast ：与 static_cast 相对，提供运行时检查 reinterpret_cast ：在编译期完成类型转换，只是对操作数的位模式做重新解释 struct 和 class 区别 访问权限和继承权限：struct 默认是 public，class 默认是 private class 还可用于定义模板参数，struct 不行 struct 和 class 如果定义了构造函数的话都不能用 {} 初始化 未定义构造函数时，struct 可用 {} 初始化 未定义构造函数时，且成员变量都是 public 时，class 可用 {} 初始化 struct 和 union struct 每个成员有自己的内存空间，union 成员共用内存空间 典型地，可以利用 union 判断大小端 内存对齐原则 数据成员对齐 第一个成员从offset为0处开始 之后每个成员的起始位置应该是该成员大小的整数倍 结构体作为成员 应该以结构体中最大元素的整数倍地址开始 收尾 结构体的总大小应该是结构体中最大成员的”最宽基本成员“大小的整数倍，不足要补齐 原因 一些平台对某些数据类型只能从特定地址开始存取，不对齐会出错 为了存取效率 指针和引用 对象是一块能存储数据并具有某种类型的存储的空间，有 值 和 地址 指针也是对象，只不过指针存的是数据的地址，通过指针访问对象需要解引用 指针常量表示指针所存储的地址不可改变 指向常量的指针表示不可通过该指针改变所指数据，但是指针的指向是可以变的 引用是变量的别名，声明时必须初始化，且之后不可改变。有空指针但是没有空引用。 深拷贝/浅拷贝 浅拷贝：新对象有着原对象属性值的的拷贝，当存在比如指针类型时，修改一个对象内的值会影响另一个对象 深拷贝：将对象的成员完整的拷贝出来，并用新的内存空间存储，修改新对象不会影响原对象 右值引用 / std::move / std::forward && ：不带类型推导时，是右值引用，如int&& ；需要类型推导时，是 universal reference，如auto&& std::move 和 std::forward 只做类型转换，不会产生可执行代码 std::move 执行无条件的类型转换 std::forward 执行有条件的类型转换，仅当输入参数是被右值初始化时才转换为右值。 典型场景：在函数内将右值初始化的形参传给另一个函数，且需要保持其右值属性时 原因：函数的形参作为参数传给别的函数时，被视为左值 迭代器 算法和容器的粘合剂 行为类似指针的对象 STL 容器 vector 原理、适用场景 原理：底层是数组，当超过容量时会重新分配内存 内存分配方式：一般按 2 倍扩容 注意：扩容后，会将原空间元素拷贝到扩容后空间，然后释放原空间。因此，如果发生了扩容，原迭代器会失效。 list 原理：底层是双向链表（环形，尾部是一个空白节点） 注意：对list的插入和拼接不会导致迭代器失效。删除操作也只是“指向被删除元素”的迭代器失效。 deque 原理：由分段连续空间组合而成，双端队列 priority_queue 原理：底层以堆实现，通常用vector做为底层容器 set 、map 原理：底层是红黑树 unordered_set、unordered_map 原理：底层是哈希表+bucket，冲突时挂链表（JAVA1.8 之后会在链表长达到一定阈值之后转红黑树）；根据最大负载因子来判断是否需要扩容，查素数表来决定扩容多大（不同实现也可能不同） 设计并发哈希表：JAVA的ConcuurentHashMap采用分段加锁（JAVA1.7）或者 CAS(Compare And Set) + synchronized （JAVA1.8）的方式；存在竞争时会先尝试自旋获取锁，一定次数后转为阻塞获取锁；put过程需要加锁，get过程不用加锁，变量用volatile修饰，保证每次都是从内存中重新获取新值 缺点：内存占用多 哈希表 哈希冲突解决方法 线性探测法：冲突时，按顺序往后寻找空位。删除时，必须是 lazy deletion（先标记，在rehash时再删除/被替换），因为一个元素的位置还关系到其他元素的排列。 二次探测：冲突时，就按当前位置加上 $1^2,2^2,3^2,...$ 往后探测。避免 primary clustering 问题 二次哈希（double hashing）：冲突时用新的哈希函数再哈希 开链法：每个位置不是只存一个元素，而是存一个链表 如何在哈希表扩容时仍然提供服务？ Redis 渐进式哈希：字典结构中包含两个 哈希表 指针。当需要扩容时，根据需要初始化备用的哈希表；然后开始将数据迁移到新的哈希表，通过一个指针指示当前迁移操作已进行到哪个哈希值；数据迁移完毕后，清空原来的哈希表以供下次rehash使用。rehash操作可以分摊到增删改查操作，以及定时任务当中（防止服务器过于空闲而长期持有两个哈希表） inline 的作用 避免频繁的函数调用消耗过多的栈空间 内联函数必须足够简单 内联只是建议，是否内联取决于编译器 内联函数最好放在头文件中，因为需要在调用点展开就要处处可见函数的定义 类的成员函数缺省是内联的。但是如果声明和定义分开，缺省就不是内联的；如果需要保持内联性质，在定义时需要加上inline关键字 空类 编译器会为空类自动 声明 构造函数、析构函数、拷贝构造函数、赋值拷贝构造函数，调用时才会 创建 空类占1字节，因为要保证每个对象都有不同的地址 C++ 虚函数原理 普通成员函数的地址在编译时就确定了，虚函数地址需要根据虚函数表查询 原理： 虚函数表指针总是存在于对象实例最前面的位置 虚表是属于类的，不属于对象，因此一个类只需要一个虚表。同一个类的对象都使用同一个虚表 派生类虚函数为新时，在虚表后面增加该函数的指针；派生类虚函数覆写基类虚函数时，在将虚表对应位置的指针置换为该函数的指针 多继承情况下，有几个继承类就有几个虚函数表 为什么析构函数要声明为虚函数？ 将基类的析构函数声明为虚函数，可以保证delete基类指针时动态绑定正确的析构函数。如果delete一个指向派生类的基类指针，而且基类析构函数不是虚函数，会产生未定义行为。 为什么构造函数不能是虚函数？ 虚函数需要通过虚表找到对应的函数调用，而对象还未实例化，虚表指针还不存在，无法找到虚表 创建对象时我们总是需要明确所创建的对象 菱形继承和虚继承 菱形继承（BC继承A，D继承BC）时，D类中会有两份 A 的成员变量 虚继承保证D类中只会有一份 A 中数据成员的拷贝 构造D类时会创建 B-in-D 虚表（AB虚表指针）、C-in-D 虚表（AC虚表指针）、D的虚表（ABC虚表指针），这七个指针又会被组织为一个表，称为VTT（Virtual Table Table） RTTI(Run-Time Type Information)，运行时类型信息 当类中不存在虚函数时，数据类型判断是编译期完成 当类中存在虚函数时，数据类型是运行时判断 实现原理：虚函数表最前面保存了RTTI信息 NULL // C #define NULL ((void*)0) // C++ #define NULL 0 C语言中 NULL 就是 0，指向NULL的指针所存的值就是0 C++ 中不允许将 void* 指针隐式转换为其他类型指针 使用 nullptr 避免数值和指针的二义性 sizeof sizeof是一个运算符，不是函数 编译期求值，所以sizeof的结果是常量 这俩自己实现的有问题 类型（可以是元素也可以是数组）：#define _sizeof(T) ((size_t)((T*)0 + 1)) 这个根本编译不过 元素：#define array_sizeof(T) ((size_t)(&T + 1) - (size_t)(&T)) C++ 模板 C++ 并不是将模板处理为能够接受任意类型的函数，而是在根据调用模板的类型生成函数 STL 内存管理 内存池 + 二级分配器 当申请的内存大于 128B 时，直接使用第一级分配器(malloc等)向系统申请内存；当申请的内存小于 128B 时，使用二级分配器在预分配的内存池中分配内存，内存池由 16 个空闲链表组织（每个空闲链表的块大小 8 - 128B 按8的倍数递增） 小对象的分配更快 减少了内存碎片的生成 C++ 11 智能指针 shared_ptr：创建额外的控制块保持引用计数，引用计数的增减是 原子 的 weak_ptr：可用于缓存等应用场景，提供 lock 调用来检测和获取指针（保证原子性） unique_ptr：禁用了拷贝构造函数和拷贝赋值构造函数 模板特化 当模板实现不能应用于任意类型时，或者对于某些类型有更好的实现时，可以使用模板特化 偏特化分为：将部分模板参数全特化（直接指定为具体类型）；对模板参数特性进行特化，比如利用模板参数声明指针、引用、模板类等等，如 std::vector& 函数模板特化，可以用函数重载代替，但是也有区别 使用重载函数时，不论是否发生函数调用，都会生成二进制代码；而使用模板特化，除非发生函数调用，否则不会生成特化模板函数的二进制代码 使用重载函数时，在分离编译模式下要注意在各个文件中包含重载函数的声明，防止调用模板函数 类模板特化 调用优先级：全特化 > 偏特化 > 一般模板 模板元编程 将运行期开销转移到编译期 会导致代码膨胀 Python 可变参数 *args ：以元组形式存储，称为数组参数 **kwargs ：以字典形式存储，称为字典参数 装饰器 装饰器本质上是一个函数，让其他函数在不更改代码的情况下增加额外的功能 def using_log(func): def wrapper(*args, **kwargs): logging.warn(\"% is running\" % func.__name__) return func(*args, kwargs); return wrapper; 容器 元组(tuple)：常作为函数的参数和返回值（输入/返回多个值）；不可更改，保护数据 列表(list)：相同数据类型数据的序列。动态数组 tuple 和 list 的区别：tuple 是不可变的，list 是可变的；tuple 一般保存异构数据，list 一般保存同类数据（保存一个坐标用 tuple，保存多个点的坐标用 list）；tuple 可以作为字典的 key，list 不可以 tuple 和 list 的联系：都是序列，都可以存储任何数据类型，都可通过索引访问 字典(dict)：键值对，描述复杂数据信息。哈希表，使用开放寻址法解决冲突 集合(set)：被实现为带有空值的字典 range 和 xrange 的区别 python2 中 range 会生成 list，xrange 是一个序列对象，惰性生成值（用到才生成） python3 中 range 跟 xrange 一样都是惰性 == 和 is 的区别 == 表示值相同 is 表示是同一个对象 Python 多线程 / 多进程 GIL，Global Interpreter Lock，全局解释器锁 由于有 GIL 锁的存在，python的多线程并不能有效利用多核，每个线程运行时都需要先去获取 GIL 锁，即同一时刻只会有一个线程运行 多进程条件下，每个进程有自己的 GIL 锁，可以并行 JAVA 语言对别 C/C++ 编译成机器码，可由操作系统直接运行；JAVA 编译为字节码，由 JVM 读取运行 C/C++ 需要程序员进行内存管理；JAVA、Python有垃圾回收机制 Python 是脚本语言，解释执行，不需要经过编译 编译器：输入源码，输出用别的语言(通常是更低级的语言)实现的源码语义程序 解释器：输入源码，输出源码执行的结果 网络 路由器和交换机的区别 交换机实现桥接功能，路由器实现路由功能 路由器可以隔离广播域，交换机不能 不同的物理接口/不同的网段需要路由，不能桥接 TCP / UDP 区别 TCP 提供 面向连接的、可靠的字节流 服务 在一个 TCP 连接中，仅有两方进行彼此通信。广播和多播不能用于 TCP TCP 使用 校验和、确认和重传机制 来保证可靠传输 TCP 给数据分节进行排序，采用累计确认来保证数据有序和不重复 采用 滑动窗口 来实现流量控制，动态改变窗口大小 来实现拥塞控制 UDP 不可靠的数据报服务 。没有序列号、确认和重传机制，因此数据报可能乱序、丢失、重复 每个数据报是有长度的，一个数据报到达后，那么该数据报的长度也一起递送给接收方。TCP 是字节流协议，没有任何（协议上的）记录边界。 无连接 。服务端 和 客户端没有连接关系，也没有握手/挥手过程 支持多播和广播 TCP 黏包问题 原因：TCP 是字节流协议，没有定义数据边界 解决方法 使用约定标记分割数据，比如 HTTP 报文的 \\r\\n 约定数据格式，比如 TLV模式（Type Length Value） TCP 建立连接 / 断开连接 的步骤 建立连接：三次握手。因为 TCP 依靠重传和确认实现可靠传输且全双工，那么客户端发起连接需要两次握手、服务端发起连接也需要两次握手；第二次、第三次握手时，服务端可以进行捎带确认，变成三次握手。三次握手也可以保证不会因为过期的SYN包而建立错误连接。 客户端端向服务端发送 SYN ，进入 SYN_SENT 状态 服务端向客户端发送 SYN ACK，由 LISTEN 进入 SYN_RCVD 状态 SYN 会携带一些选项控制信息： MSS 最大报文长度，一般1460字节（仅计算TCP载荷） Timestamp permit SACK permit window scale 客户端收到 SYN ACK 后进入 ESTABLISHED 状态，回复 ACK ，服务端收到后进入 ESTABLISHED 状态 断开连接 路径 MTU 发现 为什么需要路径MTU发现？ 报文在网络中传输的路径是不确定，如果报文过大会导致分片，分片会导致路由器负担过重，增加延迟，增大丢包概率。因此需要动态确定路径 MTU 如何进行路径MTU发现？ 将 IP 报文的 DF 标志位设为 1，禁止分片。如果收到 ACK 则下一次探测会使用更大的报文；如果被路由器丢弃收到 ICMP 报文，则使用 ICMP 中通告的 MTU 值；若路由器丢包但是不回复 ICMP 导致超时，则减小MTU值。 TCP 会将路径的MTU值保存在socket的MSS中，接下来用新的 MSS 发送探测包和普通数据包 TCP 会同时使用socket中的MSS和路由表中的MTU // 客户端 void tcp_connect_init(struct sock *sk) { tcp_mtup_init(sk); // MSS MTU 同步 tcp_sync_mss(sk, dst_mtu(dst)); // 服务端 struct sock *tcp_v4_syn_recv_sock(struct sock *sk, struct sk_buff *skb, struct request_sock *req, struct dst_entry *dst) { tcp_mtup_init(newsk); // MTU MSS 同步 tcp_sync_mss(newsk, dst_mtu(dst)); 网络编程 各个系统调用分别做了什么事 socket：分配套接字，创建 sock 和 socket 结构，内核直接操作的是 sock，socket 是为了适配虚拟文件系统 bind：将套接字与指定端口绑定 listen：用户创建套接字时默认为一个主动连接的套接字，调用listen使得套接字变为一个监听套接字，并维护一个（一定容量的）用户请求队列。此时已经可以接受连接，完成三次握手的连接会在等待队列中等待accept调用取走；既然三次握手可以完成，也就可以接收数据，但是有缓冲区限制 backlog：连接请求队列长度。C语言中，部分实现对于置0的操作是认为队列长度为默认最大值 accept：创建新的 socket 结构表示新连接，从全连接队列里取出已完成三次握手的连接，并设置 socket 和 sock 的对应关系 connect：发起第一次握手，之后由协议栈完成 服务端 / 客户端 服务端：socket、bind、listen、accept 客户端：socket、connect HTTP HTTP 1.1 和 HTTP 1.0 的区别 * 数字证书 数字证书的有效性 是否在有效期内 数字签名是否正确。数字签名是数字证书信息的哈希值经过认证机构的加密得到 cookie 和 session 浏览器怎么确定使用 HTTP 还是 HTTPS？ 当用户使用HTTP访问时，服务器会进行重定向，重定向到 HTTPS 域名。并且可能会设置过期时间，即再过期时间内，都直接将 HTTP 转换为 HTTPS ，无需重定向。 从输入网址到获取页面的全过程 DNS 解析。浏览器依次查找自身的 DNS 缓存、操作系统的 DNS 缓存、本地 DNS 服务器、向顶级 DNS 服务器发起递归或者迭代查询，直到找到对应的 IP 地址 发起 TCP 连接，进行三次握手 发送 HTTP 请求报文 服务器回复响应报文 浏览器渲染页面 反爬虫 检查 User-Agent 等首部字段 限制 ip，限制访问频度 设置验证码等验证措施 系统 同步和异步：关注的是消息通知机制 同步：发出一个调用之后，在没有得到结果前，调用不返回 异步：调用发出后，不等待结果直接返回，被调用者通过状态/通知来通知调用者，通过回调函数来处理结果 阻塞与非阻塞：等待调用结果时的状态 阻塞：阻塞调用是指结果返回之前，线程会被挂起 非阻塞：在不能立刻得到结果之前，该调用不会阻塞当前线程 软链接/硬链接 软链接：文件A/B的inode不同，但是A的内容是B的路径，所以打开A最终读取的文件还是B；A依赖于B，删除B再打开A会报错 硬链接：通过不同的文件名访问同一个文件（多个文件名对应同一个inode），对文件内容的修改会影响到所有文件名；但是删除一个文件名不会影响其他文件名的访问。 硬链接就是直接指向，软链接就是间接指向 ln 创建硬链接 / ln -s 创建软链接 库函数和系统调用 库函数处于用户态，系统调用处于内核态 库函数运行时间属于”用户时间“，系统调用运行时间属于”系统时间“ 库函数是过程调用，开销小；系统调用需要用户空间和内核空间切换，开销大 用户态到内核态的切换方式 系统调用：系统调用是通过 0x80 软中断陷入内核，执行异常处理，即根据系统调用号执行相应的操作 异常：同步中断，是指令执行时CPU控制单元产生的。比如缺页中断（访问已分配虚拟地址，但为分配物理内存的的地址时产生） 中断：异步中断，由 其他 硬件依据CPU时钟随机产生 中断和异常的处理是利用中断描述符表中的中断描述符，属于系统描述符中的门描述符。 Linux 用中断门处理中断，用陷阱门处理异常 中断处理一般分为 中断响应（硬件实施） 和 中断处理（软件实施） 进程和线程 进程 进程是资源分配的最小单位 进程之间是相互隔离的，每个进程有自己的地址空间（虚拟地址空间），所以每个进程看到的地址空间是一致的 线程 线程属于进程，默认一个进程一个线程 线程之间是对等的一个线程可以杀死任意跟它对等的线程，或者等待它的对等线程终止 线程是CPU调度的最小单位 同步方法 临界区：临界区不是内核对象，只能用于同步进程内的线程，是用户方式的同步 互斥量（mutex）：互斥量可以命名，可以跨进程使用 信号量：控制有限数量的资源，资源数为1时就是互斥量 事件：通过通知操作来保持同步 进程调度算法 先来先服务 每次从就绪队列中取出最先到达的进程运行 简单，基本公平 短作业（进程）优先 每次取所需完成时间最短的进程运行 缺点：需要直到进程完成时间；对长作业不利；未考虑任务紧迫程度；无法实现人机交互 优先级调度 每次取优先级最高的进程运行 抢占式：进程运行期间若有更高优先级的进程申请处理器则立即让出；适用于实时性要求严格的系统 非抢占式：处理器一被分配给某个进程，直到其运行完/被阻塞之前都不能被抢占；适用于实时性要求不高的系统 高相应比优先 响应比也是一种优先级，特点是要求服务时间越短、等待时间越长则优先级越高 同时兼顾了长短作业，但是增加了响应比计算开销 时间片轮转 进程按先来先服务排成队列，取队首运行一个时间片后，将其挂到队尾，然后再取队首运行，如此往复 多级反馈队列调度 设置n个优先级队列，队列优先级依次递减，而时间片大小依次递增 有新进程来时，先放入第一个队列，若在一个时间片内不能完成，则放入下一个队列；第n个队列采用时间片轮转算法 只有当 1~i-1 队列都为空时，第 i 个队列的任务才会运行 抢占式优先级，若进程运行时，有更高优先级的任务进入前面的队列，则立即让出处理器，处理新任务 进程间通信方式 管道 匿名管道：半双工（某些系统全双工，默认情况我们不假定具有此特性）；只能在具有公共祖先的进程间使用；部分系统，如BSD，是用 Unix域套接字实现管道的；当最后一个访问管道的进程终止，管道就被删除 FIFO（命名管道）：半双工；可在任意进程间使用；FIFO 是一种文件类型；FIFO 的路径名存在于文件系统；当最后一个引用 FIFO 的进程终止时，FIFO 仍留在文件系统中，但是数据会被清空 表现形式：pipe返回两个文件描述符。当要求写入的数据小于 PIPE_BUF 时，多进程写不会穿插；当有进程要写的数据超过缓冲区大小时，多进程写数据可能穿插 消息队列 消息的链接表，存放在内核中，由消息队列标识符标识 并不一定按先进先出顺序取消息，也可以按照消息类型字段取 信号量 一个计数器，用于多进程对共享数据的访问，内核中实现 系统中信号量有限 通过 SEM_UNDO 标志位防止进程终止时不释放占用的资源 原理：实际实现中信号量被定义为一个或多个信号量值的集合，创建信号量时要指定该集合中信号量值的数量，以semid_ds结构表示；每个信号量由一个无名结构表示 记录锁：创建一个空文件，将该文件的第一个字节作为锁字节。分配资源时对该字节获得一个写锁，释放时解锁。当进程终止时，内核回自动释放该锁 虽然记录锁比信号量慢，但是没有特别必要时建议用记录锁，简单，且没有资源回收的麻烦 共享内存 允许两个或多个进程共享一定的存储区 需要自己进行同步，通常用信号量同步（记录锁也可） 需要主动删除，否则留存于系统 默认连接时，共享内存在虚拟地址空间中紧靠在栈空间之下 mmap映射的存储段与文件相关联；XSI共享内存没有这种关联 消息队列、信号量、共享内存称为 XSI IPC，它们不使用文件系统名字空间，而是构造自己的名字空间。 标识符：内部使用，递增使用，直到标识符达到最大值再绕回0。文件描述符则每次从最小可用开始。 键（key）：外部使用，即用户通过key访问，由内核转换为标识符 XSI IPC 存在的问题 在系统范围内起作用，没有引用计数 在文件系统中没有名字，不能使用文件IO函数和IO复用函数，所以为它们新增了很多系统调用 套接字：高级进程间通信 虚拟内存 概念：为了方便内存管理引入的中间层，进程使用虚拟地址寻址，CPU 和 操作系统共同负责地址翻译，找到实际的物理地址。 作用 将主存看作是磁盘地址空间的高速缓存，只存放活跃的磁盘数据 统一了进程的地址空间，简化了内存管理 保证了进程地址空间不被其他进程破坏 分段和分页：粒度不同 分段：程序分为代码段、初始化数据段、未初始化数据段、堆、栈 分页：程序按固定大小分页，一般系统页大小为 4KB 内存分配 使用系统调用直接申请内存性能较差，往往由程序运行库向系统申请、管理一定的内存，当不够时运行库再向系统申请 malloc / free 分配和释放内存，底层由 brk / mmap / munmap 系统调用实现 brk / mmap 分配的都是虚拟地址，当第一次访问时才建立与物理地址的映射 brk 扩大程序的数据段，把扩大的部分当作分配的空间（开销小） mmap 则是申请一段虚拟内存空间（可映射到文件、任何位置的内存），glibc 中的 malloc 函数对于小于 128KB 的请求，会在现有的堆空间中分配；大于 128KB 的请求，调用 mmap 分配一块匿名空间（开销较大） 堆分配算法 空闲链表法（malloc） 分配时查找空闲链表，找到合适的块拆分；释放时，将内存块重新挂上空闲链表；如果找不到足够大的块，则先进行碎片整理再尝试分配 位图 将内存分为大小相同的块，分配时，总是分配整数个块，第一个块称为头，其余的称为主体，未分配的为空闲。因此一个块只需要两个比特位表示 对象池 将堆空间分成大小相等的块，它认为某些场合每次分配的空间相等，所以每次直接就返回一个块的大小 实际中堆分配算法往往是混合式的 mmap 作用：将文件或者其他对象映射到进程的地址空间，实现文件磁盘地址与进程一段虚拟地址的一一对应关系。 原理 进程启动映射过程，分配一段虚拟地址作为映射空间 构建文件地址和虚拟地址映射关系，此时数据并没有读入主存 当进程对该虚拟地址空间进行访问时，引发缺页异常。系统先在 swap cache 中查找是否有所需内存页，找不到再从磁盘读入 如果进程改变了其中内容，一定时间后系统会自动写回文件（也可强制同步） 进程终止或调用munmap，映射解除。关闭文件描述符不解除映射。 常规文件操作：页缓存在内核空间中，从磁盘到页缓存到用户空间，需要 两次内存拷贝 ，写回时也需要两次 进程发起读文件请求 查找文件描述符表，找到 inode inode 查找所请求页是否在页缓存中，如果在则直接返回页内容 如果不在，则从磁盘读入主存，再重新发起请求 mmap优势 只需一次内存拷贝即可直接将数据传入用户空间（实际存在内核空间，只是虚存地址映射到了内核空间） 提供进程间共享内存的实现方式。比如使用 /dev/zero 文件，无需存在一个实际文件，但是只能在相关进程中起作用。映射完之后，可直接关闭文件 在无关进程中共享存储 使用 XSI 共享存储函数 mmap将同一文件映射到它们的地址空间，并使用 MAP_SHARED 标志 线程池的原理、目的、实现 本质：对象池的应用。开辟一块内存存放待使用的对象，需要时取用，用完后归池。避免重复创建的对象的开销，避免创建过多对象占用资源 实现：初始化时创建一定数量的线程，等待在条件变量 / IO 复用函数上；有任务来时，将任务放入任务队列，并唤醒一个线程处理。 死锁 概念：两个或两个以上线程在执行过程中由于资源竞争或通信引起的阻塞现象，且若无外力作用，无法继续推进 原因： 系统资源不足 程序推进顺序不当 资源分配不当 条件： 互斥条件：一项资源只能被一个进程使用 请求与保持条件：进程因请求资源被阻塞时，已获取的资源不释放 循环等待条件：进程间形成头尾相连等待资源的关系 不剥夺条件：进程已获得的资源只能自己主动释放，不能被剥夺 死锁例子 哲学家进餐问题：当所有哲学家同时决定进餐并拿起同一方向的筷子就发生了死锁 解决方法 死锁避免：银行家算法 一个进程申请分配资源时，先试探性分配给该进程资源，然后通过安全性算法判断分配后，系统仍处于安全状态，则实际分配；否则让进程继续等待 Linux IO 模型 / Direct IO Linux IO 包括五种： IO 分为两个阶段，等待数据 和 将数据从内核复制到用户空间。 阻塞 IO：调用 IO 函数之后就阻塞，直到数据完成从内核到用户空间的复制 非阻塞 IO：调用 IO 函数之后，若没有数据准备好则立即返回；否则等待数据从内核复制到用户空间完成 信号 IO：注册信号处理函数，数据准备好时，内核发送信号，调用信号处理函数。信号处理函数再调用 IO 函数，等待数据复制完成 IO 多路复用：等待在 IO 复用函数上（select、poll、epoll），当有数据准备好时返回可读事件，然后调用 IO 函数等待复制完成。IO 复用允许我们等待多个描述符。 异步 IO：让内核将这两个阶段都完成之后再通知用户继续处理。与信号 IO 区别就是，信号 IO 告诉用户什么时候启动 IO 操作，异步 IO 告诉用户 IO 操作何时完成 零拷贝技术 零拷贝不是无拷贝，而是尽量避免拷贝 典型技术有 mmap、sendfile 文件 IO 模型：Direct IO / Buffered IO（比如默认的read、write） Direct IO：应用程序绕过内核直接读写存储设备。对于自缓存程序（比如某些数据库实现），其自身比操作系统更了解数据状态，可以实现更好的换入换出算法，那么绕过内核缓存可以获得更好的性能 IO 复用 select、poll select 用 fd_set 来表示描述符集，有数量限制；poll 使用 pollfd 结构来表示描述符，解除了数量限制 内核和用户态之间描述符集的拷贝开销；有事件发生时需要遍历所有描述符来收集事件 epoll epoll_ctl 和 epoll_wait 的拆分，使得只在描述符集变化时才进行描述符集的更新；内存映射解决返回就绪fd集合的拷贝问题 有事件发生时，epoll 会将就绪fd放入 ready_list ，免去了遍历整个描述符集的开销 RAID（Redundant Array of Independent Disks，独立冗余磁盘阵列） RAID把多个硬盘组合为一个逻辑硬盘，因此操作系统只会把它当作一个实体硬盘 主要目的是为了 提升性能 或 数据冗余 标准 RAID RAID 0：把多个硬盘并联起来，读写时可以并行处理，无容错能力 RAID 1：两组以上的 N 个磁盘互作镜像，在并行条件下读取速度快，写入速度有所降低 其他RAID就要用上编码知识了 常见代码设计实现 布隆过滤器 特性：查到的 不一定 存在，查不到的 一定不 存在 反转特性如何实现？（查到的 一定 存在，查不到的 不一定 存在） 原理： 创建：根据数据量大小和允许的错误率确定 Bitmap 大小 和 哈希函数数量 k 插入：对数据进行 k 次哈希，比对 Bitmap 的 k 个位置进行置位 查询：对数据进行 k 次哈希，若 k 个位置都被置位，则数据大概率存在；若 k 个位置不全置位，则数据一定不存在 适用： 数据量大、空间限制严格、容忍一定错误率的情况 对于误报可以建立白名单来防止误报 应用场景 防止数据库穿库：减少不存在行或列的磁盘查找 防止缓存穿透：查询一个不存在的数据时，先到缓存中找，找不到再到存储层找。因为该数据不存在，所以不会被写入缓存，假如频繁查询该不存在的数据会严重影响系统的性能 WEB 拦截：防止重复请求 大规模文本文件，求前十词频的单词 首先通过哈希分流多个机器 或 分成多个小文件 利用哈希表统计出每个小文件的词频，然后用大小为 K 的小根堆得到 top K 单词 对每个文件的 top K 单词进行词频排序后，在通过 外部排序 或 小根堆 选出每个机器上的 top K 继续 外部排序 或 小根堆 选出全局的 top K str系列函数（assert是宏不是函数） // 1. 注意assert判空 // 2. '\\0'也会被拷贝 char* strcpy(char* dst, const char* src) { assert((dst != NULL) && (src != NULL)); char* res = dst; while ((*dst++ = *src++) != '\\0'); return res; } size_t strlen(const char* str) { assert(str != NULL); size_t len = 0; while (*str++ != '\\0') len++; return len; } char* strcat(char* dst, const char* src) { assert((dst != NULL) && (src != NULL)); char* res = dst; while (*dst++ != '\\0'); while ((*dst++ = *src++) != '\\0'); return res; } int strcmp(const char* s1, const char* s2) { assert((s1 != NULL) && (s2 != NULL)); while (*s1 == *s2 && *s1 != '\\0' && s2 != '\\0') { s1++; s2++; } return *s1 - *s2; } 单例模式 // C++11最佳版, Lazy。C++11之后static是多线程安全的 class Singleton { private: // 注意要声明为私有和delete，防止任何形式的主动构造 // Effective C++ 第6条不想编译器生成就要明确拒绝 Singleton() {} ~Singleton() {} Singleton& operator= (const Singleton&) = delete; Singleton(const Singleton&) = delete; public: // 注意要声明为静态函数 static Singleton& getInstance() { static Singleton instace; return instace; } } // Eager class Singleton { private: static Singleton instance_; Singleton() {} ~Singleton() {} Singleton& operator= (const Singleton&) = delete; Singleton(const Singleton&) = delete; public: static Singleton& getInstance() { return instance_; } }; Singleton Singleton::instance_; 生产者消费者（有锁） queue Q; mutex mtx; condition_variable p, c; static const int MAX_SIZE = 100; void producer(int id) { while (true) { unique_lock lock(mtx); p.wait(lock, [] { return Q.size() != MAX_SIZE; }); Q.push(id); c.notify_all(); } } void consumer() { while (true) { unique_lock lock(mtx); c.wait(lock, [] { return Q.size() != 0; }); Q.pop(); p.notify_all(); } } LRU算法 template class LRU { private: using PKV = pair; using Iter = list::iterator; unordered_map dict; list lru; size_t max_size; public: LRU(size_t size) : max_size(size) {} PKV query(const KEY& key) { if (dict.count(key) == 0) return {}; return *dict[key]; } void insert(const KEY& key, const VALUE& value) { if (dict.count(key)) { Iter iter = dict[key]; lru.erase(iter); } else if (lru.size() == max_size) { PKV p = lru.front(); lru.pop_front(); dict.erase(p.first); } lru.push_back({key, value}); dict[key] = lru.end(); --dict[key]; } } memcpy，考虑内存重叠、边界条件 void* memcpy(void* dst, void* src, unsigned int n) { assert(dst != NULL); assert(src != NULL); void* res = dst; if (dst = (char*)src + n) { while (n--) { *(char*)dst = *(char*)src; dst = (char*)dst + 1; src = (char*)src + 1; } } else { dst = (char*)dst + n - 1; src = (char*)src + n - 1; while (n--) { *(char*)dst = *(char*)src; dst = (char*)dst - 1; src = (char*)src - 1; } } return res; } 实现 bitmap 结构，包括数据的存储和插入方式 class BitMap { private: vector bm; size_t cap; public: BitMap(size_t n) : bm(n / 8 + 1), cap(n) {} int set(size_t i) { if (i > cap) return 0; int index = i / 8; int shift = i % 8; bm[index] |= (0x1 cap) return false; int index = i / 8; int shift = i % 8; return (bm[index] & (0x1 cap) return 0; int index = i / 8; int shift = i % 8; bm[index] ^= (0x1 实现 unordered_map，键为 string，value 不限，冲突解决办法 平面上百万个点，求每个点最近的k个点 游戏中已知各个小怪的坐标，你的技能是一个圆形范围，求能打到的小怪 无锁队列（以 DPDK 的 rte_ring 为例） struct rte_ring { /** Ring producer status. */ struct prod { uint32_t watermark; /** struct rte_ring 结构中主要包含三部分：生产者信息、消费者信息、消息队列。每个部分都是 Cache Line 对齐的，确保读取某部分信息时不会因为字节对齐而越界读取其他部分的信息。 CAS（Compare And Swap/Set）同步原语操作控制变量，隐式总线加锁 无论生产者还是消费者，都是先更新head指针预约生产/消费数量，操作完成后再更新tail指针 智力题 64匹马8跑道，最少需要几场得到最快的4匹马 分成 8 组比 8 场，淘汰每组的后 4 名 每组的第一名比 1 场，淘汰后四名所在的组，得到所有马中最快的马 第一名所在组的剩下 3 匹马，第二名所在组前 3，第三名所在组前 2，第四名所在组前 1，一共 9 匹马取前3 任取 8 匹比 1 场得到前3 剩下的一匹与前三比一场，得到真正的前 3 一共 11 = 8 + 1 + 1 + 1 场 飞机加油问题：每个飞机只有一个油箱；飞机之间可以相互加油（注意是相互，没有加油机）；　一箱油可供一架飞机绕地球飞半圈。那么为使至少一架飞机绕地球一圈回到起飞时的飞机场，至少需要出动几架飞机？ 3架飞机，5架次 ABC 3架同时起飞，1/8处，C给AB加满油，C返航，1/4处，B给A加满油，B返航，A到达1/2处，C从机场往另一方向起飞，3/4处，C同已经空油箱的A平分剩余油量，同时B从机场起飞，AC到7/8处同B平分剩余油量，刚好3架飞机同时返航 倒水问题 小鼠试毒 1000瓶药中1瓶有毒，服用后1h毒发，那么1h需要几只鼠找出毒药 10只。1000 假如可以测两轮，10只鼠可以测几瓶药 两轮一共10只：三进制编码，对应位为1的第一轮用，为2的第二轮用，可以测3的十次方瓶 每轮10只：第一轮每只喝1024瓶混合的，找出哪个1024包含毒药；第二轮二进制编码。可以测2的二十次方 1000瓶中有两瓶毒药，需要几只鼠 1000取2有499500种取法，需要19只鼠。将毒药两两混合，混合后的药用二进制编码 16瓶中1瓶毒，最少几只鼠找出14瓶无毒 16的二进制有4位，要找14瓶则允许最低位待定（排除两种情况），所以需要三只鼠 统计每秒在线人数 记录结构（用户，上线时间，下线时间） 数组 change[i] 表示 第 i 秒变化的人数，若第 i 秒有人上线则 +1，有人下线则 -1 数组 online[i] 表示 第 i 秒在线的人数，online[i] = online[i-1] + change[i]，即第 i 秒的在线人数等于第 i-1秒的在线人数加上第 i 秒变化的人数 小范围随机数生成大范围随机数，比如用 [1,5] 随机数生成 [1,7] 随机数 (randN() - 1) * N + randN() 得到范围 [1, N^2] 随机数 将 randN() 看作是 N 进制的一位，独立生成每一位 数据库 B树：平衡多路查找树 结构 所有节点内的关键字按递增排序，既保存关键字也保存数据 非叶子节点的子节点数至少为 2 个，至多为 M 个 所有叶子节点均在同一层 一个关键字只在一个节点中出现一次 优势 每个节点包含的关键字更多，有利于利用cache特性 层次更少，需要的查找次数更少 允许不完全填充来加快插入和删除 B+树：B树变体 结构 每个节点的 关键字数目与指针数目相同 ，关键字不保存数据，只用于索引，数据都保存在叶子节点中 所有叶子节点合起来保存了所有关键字和数据 根节点关键字是所指子树的最大关键字 左边叶子节点会保存指向右边叶子节点的指针 优势 中间节点不保存数据，因此可以容纳更多关键字，查找树更加矮胖 对于范围查询，B+树只需遍历叶子节点，B树需要中序遍历 每次查询都需要找到叶子节点，查询速度稳定 天然有序 B*树：B+树变体 结构 初始化关键字个数比B+树更多 非叶节点会保存兄弟节点指针，当一个节点满时，B+树会分裂，B*树会先尝试向兄弟节点转移关键字，失败后再分裂 数据库中join的类型和区别 数据库的 ACID 工具 GCC / G++ 编译链接的过程 流程 预编译：处理 #include / #define 等预编译指令，生成 .i / .ii 文件 编译：目标代码生成，生成 .s 文件 汇编：翻译成机器码，生成 .o 文件 链接：地址空间分配、符号决议、重定位，生成 .out 文件 程序运行 glibc入口：_start -> __libc_start_main -> exit -> _exit 。其中 main(argc, argv, __environ) 函数在 __libc_start_main 里执行。 动态库和静态库 静态库链接时回将代码拷贝一份到可执行文件当中，因此运行时无需依赖、可执行文件体积更大、库改变时文件需要重新编译 动态库链接时仅在可执行文件中保存重定位和符号表信息，在程序运行时才完成真正的链接过程，因此运行时需要环境中存在所需动态库、可执行文件体积更小、库改变时对可执行文件无影响 通常编译默认是动态链接，静态链接需要指定 -static 参数 Git git 和 svn 对比 SVN 是集中式管理，大家都是跟中央服务器交互 Git 是分布式管理，每个开发者都可以克隆一个完整的仓库，可以本地提交 git merge 和 git rebase 区别 merge 会创建新的 commit，完整的保留 commit 历史，commit 记录会比较复杂 rebase 会合并 commit 历史，代码出现问题不容易定位，因为记录被覆写，好处是commit记录干净 GDB / Valgrind coredump 怎么调试：用 gdb 调试 core 文件（ulimit -c 查看是否开启 core 文件记录） gdb core bt 查看调用栈 frame 跳转栈帧 p XXX 打印变量值 segmentation fault 非法指针解引用：指针指向一个不允许读写的地址，而试图用该指针去读写该地址 内存泄漏检查 valgrind --tool=memcheck --leak-check=full 不使用工具如何检测内存泄漏，hook 内存分配函数打log Linux 文件夹作用 /boot ：引导程序、内核的存放目录 /sbin ：超级用户可以使用的命令，通常是设计系统管理的命令 /bin ：普通用户可以使用的命令存放的目录 /lib ：根目录下的共享库目录 /dev ：设备文件目录 /home ：普通用户目录 /etc ：全局配置文件存放目录 /root ：root用户目录 /proc ：特殊文件目录，并不保存在磁盘中，显示的是内存的信息。其下有进程ID命名的文件夹，文件夹内不同的文件记录了不同的信息（比如CPU、网络、内存占用等等信息） /proc/sys/kernel/threads-max ：系统最大支持线程数 /proc//status ：可以看线程大致情况 /mnt ：临时挂载目录 /var ：通常用于缓存大小经常变化的文件，比如日志文件、缓冲文件等 /tmp ：临时文件目录，可能会被系统自动清空 Linux 下线程的实现 Linux 下用轻量级进程模拟线程，使用 clone 调用，指定共享的资源 ”一对一“模式，一个线程对应一个轻量级进程实体 Linux的\"线程\"和\"进程\"实际上处于一个调度层次，共享一个进程标识符空间 在LinuxThreads中，专门为每一个进程构造了一个管理线程 ，负责处理线程相关的管理工作（创建、销毁等） 在LinuxThreads中，管理线程的栈和用户线程的栈是分离的，管理线程在进程堆中通过malloc()分配一个THREAD_MANAGER_STACK_SIZE字节的区域作为自己的运行栈 Linux 中还有内核线程的概念，内核线程完整的存在于内核空间，不会发生内核用户态切换 存在的问题 Linux 不支持真正意义上的线程，而是使用轻量级进程模拟，这些进程拥有自己的进程 id，这与 POSIX 定义的同一进程的所有进程共享一个进程 id 和父进程 id 是相违背的 常用指令 查看进程 ps aux ，实时查看进程状态 top ，top -H -p 查看某进程的所有线程 磁盘使用情况 df -h ，内存使用情况 free -h 查看网络连接情况 netstat ，查看网络带宽占用 iftop ，查看硬件带宽 ethtool 将指定信号送至程序 kill ，默认发送 SIGTERM，比如强制杀死进程（发送 SIGKILL(9)） kill -9 在指定目录下查找文件 find 正则表达式 /pattern/ ：模式串需用 // 包围，特殊字符用 \\ 转义。整个表达式用双引号包围 ^ 行首，$ 行尾 . 任意单个字符，* 某个字符出现了0次或多次 [] 匹配字符集合，如 [a-zA-Z] 匹配所有26个字符，[^a] 匹配非a字符 grep grep [参数] \"pattern\" [file] -n 显示行号 -r 递归查找 sed(stream editor) 常用形式 sed \"[n,m]/pattern/target_pattern/\" -i 表示直接在文件中修改 sed命令：s 替换，d 删除行 替换标记：g 行内全替换，p 打印行（和 -n 一起使用，只打印发生了替换的行） awk awk [-F \"分隔符\"] '条件 {动作}' $0 表示当前行，$1 表示以分隔符为界的第1个字段，以此类推 内置变量 NF 表示当前行字段数量，因此 $NF 表示当前行最后一个字段 NR 表示当前是第几行 FS 字段分隔符，RS 行分隔符 FILENAME 当前文件名 内置函数 toupper()/tolower() 转换大小写 xargs 将标准输入转换为命令行参数，通常与管道连用 echo \"one two three\" | xargs mkdir 等效于 mkdir one two three -n 指定每次将多少项作为命令行参数，-L 指定每次将多少行作为命令行参数 统计词频 cat words.txt | xargs -n 1 | sort | uniq -c | sort -nr | awk '{print $2\" \"$1}' 读取文件 拆分单词 单词排序（把相同的单词放在一起） 统计词频（uniq -c只会统计临近的重复，所以排序不能省） 词频排序 打印 Linux 内核定时器实现 低精度用层级时间轮实现 高精度用红黑树组织 其他 Ngnix Redis 网络技术 云计算网络 大规模、分布式 虚拟化：用户无需关心具体硬件，只需选择配置即可 高可用性和扩展性 按需服务 安全 By HypoGump，使用知识共享 署名-相同方式共享 4.0协议发布            此页面修订于： 2020-10-06 11:38:28 "}}