---
description: Effective C++ 读书笔记
---

# Effective C++

## 第一章

### 条款02 尽量以 const / enum / inline 替换 \#define

* 使用define时，你所使用的名称可能并未进入记号表
* define只是单纯的做文本替换，可能会导致代码膨胀。比如 `#define X 1.11` 会使目标码出现多份 1.11，使用 `const double x = 1.11` 就不会有这个问题
* const 成员变量需要在类外再次声明，一般放在实现文件中
* define 没有作用域的限制，只要被定义，除非 undef，否则一直有效
* 对于形似函数的宏应该考虑用 inline 函数替换

## 第二章 构造、析构和赋值操作符

### 条款05 了解 C++ 默默编写并调用了哪些函数

* 一个空类，编译器会自动声明 **构造函数、拷贝构造函数、拷贝赋值操作符、析构函数** 。**都是public且inline的** 。当它们 **被调用时才会被实际创建** 。

  ```cpp
  class Empty {};

  // 编译后
  class Empty {
  public:
      Empty() {}
      Empty(const Empty& rhs) {}
      ~Empty() {}

      Empty& operator= (const Empty& rhs) {}
  }
  ```

* 当你自己声明了一个构造函数，编译器就不会自动生成无参的默认构造函数。
* 默认的拷贝构造函数，对于有自己的拷贝构造函数的成员，调用其拷贝构造函数；对于内置类型，则拷贝他的“每一个bit”
* 对于内含 引用成员/const 成员 的类，需要自己定义拷贝赋值操作符
* 对于基类的 拷贝赋值操作符 声明为private的派生类，编译器不会给派生类生成 拷贝赋值操作符

### 条款06 不想编译器生成函数就要明确拒绝

* 将函数声明为 private，并且只声明不定义
* C++ 11 中应该使用 delete 关键字

### 条款07 为多态基类声明 virtual 析构函数

* delete 一个指向派生类的基类指针，且基类析构函数非虚函数，是未定义行为
* 如果一个类包含虚函数，那么它的析构函数也应该是虚函数
* 如果class不打算作为基类使用，那就不要使用 virtual 关键字

### 条款08 别让异常逃离析构函数

* 析构函数中的异常应该被”吞下“（忽略）或者终止程序
* 客户如果需要对某个操作的异常做出反应，类应该提供一个该操作的普通函数

### 条款09 不在构造和析构过程中调用virtual函数

* 在构造函数中调用虚函数的话，因为基类先于派生类构建，基类构造函数调用虚函数时要么链接错误（无定义时），要么调用的是基类的函数（有定义时）
* 在析构函数中调用虚函数的话，因为派生类先于基类析构，基类析构函数调用虚函数时派生类已经失效了

### 条款10 令 operator= 返回一个 reference to \*this

### 条款11 在 operator= 中处理"自我赋值"

### 条款12 复制对象时勿忘其每个成分

